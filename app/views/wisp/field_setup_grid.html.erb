<script>
  var PCT_COVER_METHOD = <%= Field::PCT_COVER_METHOD %>;
  var LAI_METHOD = <%= Field::LAI_METHOD %>;
  let lastFieldSel;
  let curFieldID;
  let crop_id;

  function loadCropGrid(field_id) {
    $('#cropDataGrid').load(
      '<%= url_for(controller: :wisp, action: :crop_setup_grid) %>',
      { field_id: field_id, user_id: user_id, farm_id: farm_id }
    );
    crop_id = $("#crop_setup").getDataIDs()[0];
  }

  function rowSelect(id) {
    if (!id) return;
    if (!lastFieldSel || id !== lastFieldSel) {
      $('#field_setup').restoreRow(lastFieldSel);
      $('#field_setup').editRow(id, true);
      lastFieldSel = id;
      field_id = id;
      loadCropGrid(field_id);
    }
  }

  function useFirstFieldRow() {
    field_id = $("#field_setup").getDataIDs()[0];
    lastFieldSel = field_id;
    crop_id = 1; // Wrong, but that's OK
    // loadCropGrid(field_id);
    return [true, '', field_id]; // This was a total shot in the dark, Googling 'jqgrid afterSubmit' gave hints
  }

  function deleteField(id) {
    $('#field_setup').delGridRow(id, {
      afterSubmit: useFirstFieldRow,
      msg: 'Delete selected record(s)?\nThis will delete all crop data\nassociated with this field.\nProceed with delete?'
    });
  }

  function addFieldDeleteButtons() {
    let fieldIDs = $("#field_setup").getDataIDs();
    let msg = "Field IDs";
    let nRows = fieldIDs.length;
    for (let i=0; i<nRows; i++) {
      let id = fieldIDs[i];
      if (nRows == 1) {
        be = "<input style='height:22px; width:35px;' type='button' value='Del' disabled='true' title='Cannot delete only field'/>";
      } else {
        be = `<input style='height:22px; width:35px;' type='button' value='Del' onclick='deleteField(${id});' ></ids>`;
      }
      $("#field_setup").setRowData(id, { act: be } );
    }
  }

  // Add new field based on et mthod selection (currently controlled by separate buttons).
  function addNewFieldRow(method) {
    let grid = $('#field_setup');
    let newField = createNewField(method);
    let field_id = newField['id'];
    set_soil_characteristics(field_id, newField['soil_type_id']);
    grid.addRowData(field_id, newField); // add a new row with the new field's data
    addFieldDeleteButtons();
    grid.editRow(field_id, true); // put new row into inline-edit mode
    loadCropGrid(field_id);
  }

  // Make a call to the server to create a new field; will return new row as JSON
  function createNewField(method) {
    let pvt = {};
    $.ajax(
      {
        type: "POST",
        url: '<%= url_for(controller: :fields, action: :post_data) %>',
        data: { pivot_id: pivot_id, parent_id: pivot_id, oper: 'add', id: '_empty', et_method: method },
        dataType: "json",
        contentType: "application/x-www-form-urlencoded", // This is so Rails knows to decode it
        async: false,
        success: function(json) { field = json; }
      }
    );
    return field;
  }

  // Propagate changes from select-clicked event onwards
  // From stackoverflow.com/questions/5247138/jqgrid-change-cell-value-and-stay-in-edit-mode
  function set_soil_characteristics_from_event(event) {
    let rowID = $(event.target).closest('tr.jqgrow').attr('id');
    soil_id = parseInt($(event.target).val(), 10);
    set_soil_characteristics(rowID, soil_id);
  }

  // Ensure that default FC and PWP values are entered, whether from a new row being created
  // or from the select box being clicked. Overwrite existing values in either case.
  function set_soil_characteristics(curFieldID, soil_id) {
    // This Ruby helper enumerates all the soil_type data, same order as the select box
    let soils = <%= soil_characteristics %>; // {1:{field_capacity_pct:15.0,perm_wilting_pt_pct:5.0},2:{...}}
    let fc = soils[soil_id]['field_capacity_pct'];
    let pwp = soils[soil_id]['perm_wilting_pt_pct'];
    $(`#${curFieldID}_field_capacity_pct`).val(fc);
    $(`#${curFieldID}_perm_wilting_pt_pct`).val(pwp);
  }

  function etMethodFormat(cellvalue, options, rowObject) {
    if (cellvalue === undefined) return '';
    return cellvalue == '1' ? 'Pct Cover' : 'LAI';
  }

  function etMethodUnformat(cellvalue, options, cell) {
    return cellvalue;
  }

  // Tag on percent sign for display
  function pctFormat(cellvalue, options, rowObject) {
    if (cellvalue === undefined) return '';
    return pctUnformat(cellvalue, options) + '%';
  }

  // Remove percent sign from displayed value
  function pctUnformat(cellvalue,options,cell) {
    if (cellvalue === undefined) return '';
    // Remove the percent sign
    let num = cellvalue.replace("%","");
    // Do we have decimalPlaces in our format options?
    if (!(options.colModel.formatoptions.decimalPlaces === undefined)) {
      // Try parsing the number as a float (could be blank or null)
      let aFloat = parseFloat(num);
      // Success?
      if (!isNaN(aFloat)) {
        // Reformat it to a string with the appropriate number of decimal places
        num = aFloat.toFixed(options.colModel.formatoptions.decimalPlaces);
      }
    }
    return num;
  }

  function addFieldDeleteButton(cl) {
    be = `<input style='height:22px;width:35px;' type='button' value='Del' onclick="$('#field_setup').delGridRow(${cl}); $('#field_setup').trigger('reloadGrid');" ></ids>`;
    $("#field_setup").setRowData(cl, {act: be } )
  }

  $(document).ready(function() {
    <%= grid_javascript_settings %>
    loadCropGrid(field_id);
    let mygrid = $("#field_setup").jqGrid({
      url: '<%= grid_data_url "fields", @pivot_id %>',
      editurl: '<%= grid_post_data_url "fields", @pivot %>',
      datatype: "json",
      colNames: ["Name", "ET Method", "Area", "Soil Type", "Field Capacity", "Perm. Wilt Pt", "Target AD", "ET Stn", "Rain Stn", "Soil Moist. Stn", "Notes", "Delete", "Pivot", "ID"],
      colModel:[
        {
          name: "name",
          index: "name",
          width: 83,
          editable: true,
        },
        {
          name: "et_method",
          index: "et_method",
          width: 25,
          editable: false,
          formatter: etMethodFormat,
        },
        {
          name: "area",
          index: "area",
          width: 20,
          editable: true,
          align: "right",
          formatter: "number",
          formatoptions: { decimalPlaces: 1 },
          editrules: { number: true, minValue: 0.0 },
        },
        {
          name: "soil_type_id",
          index: "soil_type_id",
          width: 40,
          resizable: true,
          align: "left",
          sorttype: "text",
          editable: true,
          edittype: "select",
          formatter: "select",
          // working example for ET methods is "1:Percent Cover;2:Leaf Area Index"
          editoptions: { 
            value: "<%= soil_types_for_select %>",
            dataEvents: [{ type: "change", fn: set_soil_characteristics_from_event }]
          },
          editrules: { required: true },
        },
        {
          name: 'field_capacity_pct',
          index: 'field_capacity_pct',
          width: 35,
          editable: true,
          align: 'right',
          formatter: pctFormat,
          unformat: pctUnformat,
          formatoptions: { decimalPlaces: 0 },
          editrules: { number: true, minValue: 0, maxValue: 100 },
        },
        {
          name: 'perm_wilting_pt_pct',
          index: 'perm_wilting_pt_pct',
          width: 35,
          editable: true,
          align: 'right',
          formatter: pctFormat,
          unformat: pctUnformat,
          formatoptions: { decimalPlaces: 0 },
          editrules: { number: true, minValue: 0, maxValue: 100 },
        },
        {
          name: 'target_ad_pct',
          index: 'target_ad_pct',
          width: 25,
          editable: true,
          align: 'right',
          formatter: pctFormat,
          unformat: pctUnformat,
          formatoptions: { decimalPlaces: 1 },
          editrules: { number: true, minValue: 0, maxValue: 100 },
        },
        // These three are hidden until we get these features running
        {
          name: 'ref_et_station_id',
          index: 'ref_et_station_id',
          width: 25,
          editable: true,
          align: 'right',
          hidden: true,
        },
        {
          name: 'rain_station_id',
          index: 'rain_station_id',
          width: 30,
          editable: true,
          align: 'right',
          hidden: true,
        },
        {
          name: 'soil_moisture_station_id',
          index: 'soil_moisture_station_id',
          width: 50,
          editable: true,
          align: 'right',
          hidden: true,
        },
        // end hidden columns
        {
          name: 'notes',
          index: 'notes',
          width: 60,
          editable: true,
          align: 'right',
        },
        {
          name: 'act',
          index: 'act',
          width: 20,
        },
        {
          name: 'pivot_id',
          index: 'pivot_id',
          width: 10,
          hidden: true,
          editable: true,
        },
        {
          name: 'id',
          index: 'id',
          hidden: true,
          width: 10,
        }
      ],
      pager: '#field_setup_pager',
      rowNum: 180,
      rowList: [180],
      imgpath: '<%= image_folder_path("jqgrid") %>',
      sortname: '',
      viewrecords: true,
      sortorder: '',
      gridview: false,
      scrollrows: true,
      autowidth: true,
      rownumbers: false,
      multiselect: false,
      onSelectRow: rowSelect,
      loadComplete: function() {
        addFieldDeleteButtons();
        let fieldIDs = $("#field_setup").getDataIDs();
        loadCropGrid(fieldIDs[0]);
      },
      subGrid: false,
      caption: "Fields <%= @pivot ? "for #{@pivot.name}" : '(select pivot above)' %>"
    }).navGrid(
      '#field_setup_pager',
      { edit: false, add: false, del: true, search: false, refresh: true },
      { afterSubmit:function(r,data){return true;(r,data,'edit');} },
      { afterSubmit:function(r,data){return true;(r,data,'add');} },
      { afterSubmit:function(r,data){return true;(r,data,'delete');} }
    )
    mygrid.filterToolbar();
    mygrid[0].toggleToolbar();
    $("#field_setup").hideCol('id');
  });
</script>

<table id="field_setup" class="scroll" cellpadding="0" cellspacing="0"></table>
<div style="margin-top: 10px; margin-bottom: 10px;">
  <button type="button" class="btn btn-light" onclick="addNewFieldRow(PCT_COVER_METHOD);">Add New Field (% Cover)</button>
  <button type="button" class="btn btn-light" onclick="addNewFieldRow(LAI_METHOD);">Add New Field (Leaf Area Index)</button>
</div>
