
<script type="text/javascript" src="https://www.google.com/jsapi"></script>

<script>
  <%= grid_javascript_settings %>
  var cur_date = "<%= @cur_date %>";
  var lastWeek;
  var nextWeek;
  setLastAndNextWeeks(cur_date);
  var initial_date = "<%= @initial_date %>";

  function parseDate(input) {
    var parts = input.match(/(\d+)/g);
    return new Date(parts[0], parts[1]-1, parts[2]);
  }

  function dateToS(date) {
    return date.getFullYear() + '-' + (1 + date.getMonth()) + '-' + date.getDate();
  }

  function setLastAndNextWeeks(date) {
    lastWeek = parseDate(date);
    lastWeek.setDate(lastWeek.getDate() - 7);
    lastWeek = dateToS(lastWeek);
    nextWeek = parseDate(date);
    nextWeek.setDate(nextWeek.getDate() + 7);
    nextWeek = dateToS(nextWeek);
  }

  // We don't know why the Google Vis API suddenly started having a cow over
  // our numbers. But this will reformat to fix it.
  function td(num) {
    if (null === num || undefined === num) { return(0.0); }
    flt = parseFloat(num); // in case it's a string
    return(parseFloat(num.toPrecision(2)));
  }

  function array_min(arr) {
    min = 10000.0;
    for (var ii = arr.length - 1; ii >= 0; ii--){
      if (arr[ii] < min) {
        min = arr[ii];
      }
    };
    return(min);
  }

  // Calculate a baseline for the graph. Easy if they're not going into negative-AD territory!
  function baseLine(ad_data, prj_data) {
    if (prj_data) {
      smallest = array_min(ad_data.concat(prj_data));
    } else {
      smallest = array_min(ad_data);
    }
    if (smallest >= 0.0) {
      smallest = 0.0;
    } else {
      // drop the baseline to a skosh below the lowest point
      smallest = Math.floor(smallest - 0.20);
    }
    return smallest;
  }

  // Callback that creates and populates a data table,
  // instantiates the chart, passes in the data and
  // draws it.
  function plotGraph() {
    // Not ready yet.
    if (!(google.visualization && google.visualization.DataTable)) {
      return;
    }
    let ad_data = null;
    let prj_data = null;
    let targ_data = null;
    let labels = null;

    url = "<%= url_for(action: :projection_data, field_id: @field_id, user_id: @user) %>&cur_date=" + cur_date;
    ad_max = td(<%= @field.ad_max %>);
    ad_min = 0.0;
    $.ajax({
      type: "GET",
      url: url,
      dataType: "json",
      async: false,
      success: function(json) {
        ad_data = json["ad_data"];
        prj_data = json["projected_ad_data"];
        targ_data = json["target_ad_data"];
        labels = json["labels"];
      }
    });

    // Create the data table.
    // Field Capacity, AD, [Target], [Projected], 0.0 AD
    const data = new google.visualization.DataTable();
    data.addColumn("string", "Date");
    data.addColumn("number", "Field capacity");
    data.addColumn({type: "string", role: "annotation"});
    data.addColumn("number", "Daily AD (in.)");
    data.addColumn({type: "boolean", role: "certainty"});
    data.addColumn({type: "string", role: "annotation"});
    data.addColumn("number", "Depleted");
    data.addColumn({type: "string", role: "annotation"});
    if (targ_data) {
      data.addColumn("number", "Target");
      data.addColumn({type: "string", role: "annotation"});
    }
    const colors = ["#555555", "#0000FF", "#FF0000", "#00AA00"]; // FC gray, AD blue, AD==0 line red [, target green]
    let ad_len = ad_data.length;
    let wsc_anno = [];
    let targ_anno = [];
    let depl_anno = [];
    for (let i = 0; i < ad_len; i++) {
      wsc_anno[i] = "";
      targ_anno[i] = "";
      depl_anno[i] = "";
    };
    wsc_anno[0] = "Field capacity";
    targ_anno[ad_len-2] = "Target AD";
    depl_anno[0] = "Depleted";
    // first_projected is set to be false for the second and subsequent points of any series of
    // projected data. So only the first one gets labeled "Projected", but if there's another series of
    // them (as weird as that would be for actual data), the first one there gets labeled too.
    let first_projected = true;
    for (let i = 0; i < ad_len; i++) {
      label = labels[i];
      row = [];
      // Projected? prj_data is an array 1-for-1 w/ad_data -- true if projected, false if "real"
      projected_anno = "";
      if (prj_data[i]) {
        is_solid_ad_line = false;
        if (first_projected) {
          projected_anno = "Projected"; // label this one
          first_projected = false;  // but ensure subsequent ones aren't
        }
      } else {
        is_solid_ad_line = true;
        first_projected = true; // ready for the next start of a projection series
      }
      row = [
        label,
        ad_max,
        wsc_anno[i],
        td(ad_data[i]),
        is_solid_ad_line,
        projected_anno,
        ad_min,
        depl_anno[i]
      ];
      if (targ_data) {
        row[row.length] = td(targ_data[i]); // Tack on target if it's present
        row[row.length] = targ_anno[i];
      }
      data.addRow(row);
    }

    if (targ_data) {
      // target line present
      series = {
        0:{lineWidth: 8, areaOpacity: 0.2, visibleInLegend: false},
        1:{pointSize: 15},
        2:{lineWidth: 8, visibleInLegend: false},
        3:{areaOpacity: 0, visibleInLegend: false}
      };
    } else {
      series = {
        0:{lineWidth: 8, areaOpacity: 0.2, visibleInLegend: false},
        1:{pointSize: 15},
        2:{lineWidth: 8, visibleInLegend: false}
      };
    }
    // Set chart options
    const title = `Calculated${projected_anno == "Projected" ? " / Projected" : ""} Allowable Depletion (inches)`
    const options = {
      title: title,
      width: "100%",
      height: 290,
      colors: colors,
      fontSize: 12,
      pointSize: 0,
      titleTextStyle: { fontSize: 18 },
      series: series,
      // Set vertical axis range to run between fudge-factored values to make the annotations show nicely
      vAxis: { baseline: baseLine(ad_data, prj_data), maxValue: Math.ceil(ad_max + 0.2) },
      annotation: { style: "line" },
    };

    // Instantiate and draw our chart, passing in some options.
    const chart = new google.visualization.AreaChart(document.getElementById("graphBox"));
    chart.draw(data, options);
  }

  // Load the Visualization API and the piechart package.
  google.load("visualization", "1.0", { "packages": ["corechart"] } );
  google.setOnLoadCallback(plotGraph);

  function curPage(initial_date_str, cur_date_str) {
    let initial_date_obj = parseDate(initial_date_str);
    initial_date_obj.setTime(initial_date_obj.getTime() - 1) // subtract an hour to prevent initial and current being the same
    let cur_date = cur_date_str;
    let cur_date_obj = parseDate(cur_date_str);
    let days = (cur_date_obj.getTime() - initial_date_obj.getTime()) / (86400 * 1000);
    let page = Math.ceil(days / 7);
    return(page);
  }

  function showSummaryBox(date) {
    $.ajax({
      type: "GET",
      url: "<%= url_for(controller: :wisp, action: :summary_box, field_id: @field, user_id: @user) %>&cur_date=" + date,
      dataType: "html",
      async: false,
      success: function(newHtml) {
        // Set the HTML of the summary box to the new stuff
        $("#summaryBox").html(newHtml);
      }
    });
  }

  function showTargetAD() {
    // adValue = 0.0;
    let adValue = <%= @field.target_ad_pct || "''".html_safe %>;
    $("#target_ad").val(adValue);
  }

  function checkDate(newDate) {
    minDate = new Date('<%= @min_date %>');
    maxDate = new Date('<%= @max_date %>');
    date = new Date(newDate);
    prevWeek = new Date(newDate);
    prevWeek.setDate(date.getDate() - 7);
    nextWeek = new Date(newDate);
    nextWeek.setDate(date.getDate() + 7);

    prevWkBtnDisabled = (prevWeek < minDate);
    nextWkBtnDisabled = (nextWeek > maxDate);

    $("#backAWeek").prop("disabled", prevWkBtnDisabled);
    $("#forwardAWeek").prop("disabled", nextWkBtnDisabled);
  }

  function changeDate(newDate) {
    // Detect if the passed-in object is coming from the calendar's "change" event, or
    // passed in explicitly by one of our button handlers
    if (newDate.type == "change") {
      cur_date = $("#date_input").val();
    } else {
      cur_date = newDate;
      $("#date_input").val(cur_date);
    }
    checkDate(cur_date);
    setLastAndNextWeeks(cur_date);
    cur_page = curPage(initial_date, cur_date);
    $("#weather").setGridParam({ page: cur_page }).trigger("reloadGrid");
    plotGraph();
    showSummaryBox(cur_date);
  }

  function hoverColor(id,hover) {
    if (hover)
      $(id).css({"background-color":"blue","color":"white"});
    else
      $(id).css({"background-color":"#DDD","color":"black"});
    }

  $(document).ready(function(){
    plotGraph();
    showSummaryBox(cur_date);
    showTargetAD();
    $("#date_input").change(changeDate);
  });

  // datepicker
  $(function() {
    opts = {
        dateFormat: "yy-mm-dd",
        minDate: "<%= @min_date %>",
        maxDate: "<%= @max_date %>"
      };
    if ("<%= @cur_date %>") {
      opts = {...opts, defaultDate: "<%= @cur_date %>"}
    };
    $("#date_input").datepicker(opts);
  });
</script>

<% @title = "Field Status" %>
<h2>Field Status</h2>

<div class="inline-flex">
  <b>Select a field:</b>
  <%= form_tag(url_for(controller: "wisp", action: "field_status", pivot_id: "", field_id: "")) do %>
    <%= select_tag "farm_id", options_from_group_for_select(@group, @farm), { onchange: "this.form.submit();" } %>
  <% end %>
  <%= form_tag(url_for(controller: "wisp", action: "field_status", field_id: "")) do %>
    <%= select_tag "pivot_id", options_from_farm_for_select(@farm, @pivot), { onchange: "this.form.submit();" } %>
  <% end %>
  <%= form_tag(url_for(controller: "wisp", action: "field_status")) do %>
    <%= select_tag "field_id", options_from_pivot_for_select(@pivot, @field), { onchange: "this.form.submit();" } %>
  <% end %>
</div>
<br><br>
<div id="fieldStatusGrid">
  <div id="fieldDataBox" class="flex-down">
    <h3>Field data</h3>
    <div class="content-box">
      <b>Farm:</b> <%= truncate(@farm.name, :length => 32) if @farm %><br>
      <b>Pivot:</b> <%= truncate(@pivot.name, :length => 32) if @pivot %><br>
      <b>Field/soil:</b> <%= truncate(@field.name, :length => 30) %><br>
      <b>Crop:</b> <%= truncate((@field.current_crop.name + " " + @field.current_crop.variety), :length => 32) %><br>
      <hr>
      <b>Root zone depth:</b> <%= @field.current_crop.max_root_zone_depth if @field && @field.current_crop %> in.<br>
      <b>Emergence Date:</b> <%= abr(@field.current_crop.emergence_date) if @field && @field.current_crop %><br>
      <b>AD at field capacity:</b> <%= sprintf("%0.2f",@field.ad_max) %> in.<br>
      <b>Initial soil moisture:</b> <%= sprintf("%0.0f",@field_weather_data.first.pct_moisture) if @field_weather_data && @field_weather_data.size > 0 %> %<br>
      <% target_ad_in_str = @field.target_ad_in ? sprintf("%0.2f in.",@field.target_ad_in) : "--" %>
      <%= form_tag(url_for :controller => "wisp", :action => :field_status, :pivot_id => @pivot, :field_id => @field) do %>
        <b>Target:</b> <input name="field[target_ad_pct]" id="target_ad" size="1"/>% (<div style="display:inline" id='target_ad_in'><%= target_ad_in_str %></div>) <input type="submit" class="btn btn-light" value="Update Target"/>
      <% end %>
    </div>
  </div>
  <div id="fieldDailyWeather" class="flex-down">
    <h3>Field daily weather</h3>
    <div class="content-box">
      <div class="flex-center">
        <div class="inline-flex">
          <button id="backAWeek" title="Previous week" onclick="changeDate(lastWeek);">&lt;</button>
          <input name="date_input" id="date_input" class='date_input' size="10" value="<%= @cur_date %>">
          <button id="forwardAWeek" title="Next week" onclick="changeDate(nextWeek);">&gt;</button>
          <button id="curDate" class="week-button" onclick="changeDate('<%= @today %>');">Today</button>
        </div>
      </div>
      <%= render "wisp/partials/field_daily_wx" %>
    </div>
  </div>
  <div class="flex-down">
    <h3>Season totals</h3>
    <div id="summaryBox" class="content-box"></div>
  </div>
  <div class="flex-down">
    <h3>Field water balance</h3>
    <div id="graphBox" class="content-box"></div>
  </div>
</div>

<h3>Projected allowable depletion</h3>
<div class="content-box">
  <% if first_projected_idx = @projected_ad_data.index { |padd| padd } %>
    <p>Two days hence, based on the max adjusted ET in the past week (i.e., worst case).</p>
    <table border="0">
      <tr>
        <th><%= @dates[first_projected_idx].strftime("%b %d")%>:</th>
        <td id="proj_ad_1"><%= sprintf("%0.2f",@graph_data[first_projected_idx] || 0.0) %> in.</td>
      </tr>
      <% if first_projected_idx < @ad_data.size %>
        <tr>
          <th><%= @dates[first_projected_idx + 1].strftime('%b %d')%>:</th>
          <td id="proj_ad_2"><%= sprintf("%0.2f",@graph_data[first_projected_idx + 1]) %> in.</td>
        </tr>
      <% end %>
    </table>
  <% end %>
</div>






